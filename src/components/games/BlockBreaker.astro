---
---

<div id="block-breaker-game" class="w-full flex-1 min-h-[400px] bg-black rounded-lg overflow-hidden border border-gray-700 shadow-2xl relative">
    <div id="bb-start-overlay" class="absolute inset-0 flex items-center justify-center bg-black/80 z-10">
        <button id="bb-start-btn" class="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition-colors">
            Start Block Breaker
        </button>
    </div>
</div>

<script>
    import Phaser from 'phaser';

    let game;
    const container = document.getElementById('block-breaker-game');
    const startBtn = document.getElementById('bb-start-btn');
    const overlay = document.getElementById('bb-start-overlay');

    class BreakoutScene extends Phaser.Scene {
        constructor() {
            super({ key: 'BreakoutScene' });
        }

        create() {
            this.physics.world.setBounds(0, 0, 800, 400);

            // Paddle
            this.paddle = this.add.rectangle(400, 370, 100, 20, 0x00ffff);
            this.physics.add.existing(this.paddle);
            this.paddle.body.setImmovable(true);
            this.paddle.body.setCollideWorldBounds(true);

            // Ball
            this.ball = this.add.circle(400, 350, 8, 0xffffff);
            this.physics.add.existing(this.ball);
            this.ball.body.setCollideWorldBounds(true);
            this.ball.body.setBounce(1);
            
            // Disable collision on the bottom edge so the ball can fall through
            this.physics.world.checkCollision.down = false;

            // Bricks
            this.bricks = this.physics.add.staticGroup();
            this.createBricks();

            // State
            this.gameStarted = false;
            this.score = 0;
            this.lives = 3;

            // UI
            this.scoreText = this.add.text(20, 20, 'Score: 0', { fontSize: '20px', fill: '#fff' });
            this.livesText = this.add.text(700, 20, 'Lives: 3', { fontSize: '20px', fill: '#fff' });
            this.statusText = this.add.text(400, 200, '', { fontSize: '40px', fill: '#fff' }).setOrigin(0.5);

            // Collisions
            this.physics.add.collider(this.ball, this.paddle, this.hitPaddle, null, this);
            this.physics.add.collider(this.ball, this.bricks, this.hitBrick, null, this);
            
            // Input
            this.input.on('pointermove', (pointer) => {
                this.paddle.x = Phaser.Math.Clamp(pointer.x, 50, 750);
            });

            this.input.on('pointerdown', () => {
                if (!this.gameStarted && this.lives > 0) {
                    this.gameStarted = true;
                    this.ball.body.setVelocity(Phaser.Math.Between(-200, 200), -300);
                    this.statusText.setText('');
                } else if (this.lives <= 0 || this.bricks.countActive() === 0) {
                    this.resetGame();
                }
            });

            // Handle window resize for fullscreen
            this.scale.on('resize', this.resize, this);
        }

        resetGame() {
            this.score = 0;
            this.lives = 3;
            this.scoreText.setText('Score: 0');
            this.livesText.setText('Lives: 3');
            this.statusText.setText('');
            this.scene.restart();
        }

        update() {
            if (!this.gameStarted) {
                 // Stick ball to paddle
                 this.ball.setPosition(this.paddle.x, 350);
                 this.ball.body.setVelocity(0, 0);
            }

            // Check for ball out of bounds (bottom)
            // 400 is the height, so > 410 handles the radius + buffer
            if (this.ball.y > 420) {
                this.handleLifeLost();
            }
        }

        resize(gameSize) {
           this.cameras.main.setViewport(0, 0, gameSize.width, gameSize.height);
        }

        createBricks() {
            // Create a 10x4 grid
            const colors = [0xff0000, 0xff8800, 0x00ff00, 0x0088ff];
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 10; c++) {
                    const x = 75 + c * 72; // Spacing
                    const y = 60 + r * 30;
                    const brick = this.add.rectangle(x, y, 65, 20, colors[r]);
                    this.bricks.add(brick);
                }
            }
        }

        hitPaddle(ball, paddle) {
            let diff = 0;
            if (ball.x < paddle.x) {
                diff = paddle.x - ball.x;
                ball.body.setVelocityX(-10 * diff);
            } else if (ball.x > paddle.x) {
                diff = ball.x - paddle.x;
                ball.body.setVelocityX(10 * diff);
            } else {
                ball.body.setVelocityX(2 + Math.random() * 8);
            }
        }

        hitBrick(ball, brick) {
            brick.destroy();
            this.score += 10;
            this.scoreText.setText('Score: ' + this.score);

            if (this.bricks.countActive() === 0) {
                this.physics.pause();
                this.ball.setVelocity(0, 0);
                this.statusText.setText('YOU WIN!\nClick to Play Again');
                this.gameStarted = false;
            }
        }

        handleLifeLost() {
            this.lives--;
            this.livesText.setText('Lives: ' + this.lives);
            this.gameStarted = false;
            
            if (this.lives <= 0) {
                this.statusText.setText('GAME OVER\nClick to Restart');
            } else {
                // Ball position logic handled by update() when gameStarted is false
            }
        }
    }

    function initGame() {
        if (game) return;

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 400,
            parent: 'block-breaker-game',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: BreakoutScene,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 800,
                height: 400
            },
            transparent: true
        };

        game = new Phaser.Game(config);
        
        // Listen for standard resize events to trigger refresh
        window.addEventListener('resize', () => {
             if(game) {
                // Small delay to allow CSS transitions to finish
                setTimeout(() => {
                    game.scale.refresh();
                }, 100);
             }
        });
    }

    startBtn?.addEventListener('click', () => {
        overlay.classList.add('hidden');
        initGame();
    });

    // Cleanup
    document.addEventListener('astro:before-swap', () => {
        if (game) {
            game.destroy(true);
            game = null;
        }
    });

    // External Trigger to Destroy/Pause (for switching)
    container.addEventListener('destroy-game', () => {
        if (game) {
            game.destroy(true);
            game = null;
            overlay.classList.remove('hidden');
        }
    });
</script>
